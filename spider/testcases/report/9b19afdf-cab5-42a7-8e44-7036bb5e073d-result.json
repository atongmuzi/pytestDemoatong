{"name": "test_movie_new_round", "status": "broken", "statusDetails": {"message": "urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate in certificate chain (_ssl.c:1056)>", "trace": "self = <urllib.request.HTTPSHandler object at 0x10d197a90>\nhttp_class = <class 'http.client.HTTPSConnection'>\nreq = <urllib.request.Request object at 0x10d197898>\nhttp_conn_args = {'check_hostname': None, 'context': None}\nhost = '127.0.0.1:8890', h = <http.client.HTTPSConnection object at 0x10d1976a0>\ntunnel_headers = {}, proxy_auth_hdr = 'Proxy-Authorization'\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update({k: v for k, v in req.headers.items()\n                        if k not in headers})\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = {name.title(): val for name, val in headers.items()}\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:1317: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>, method = 'GET'\nurl = '/html/gndy/dyzz/list_23_1.html', body = None\nheaders = {'Connection': 'close', 'Host': 'www.dytt8.net', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:1229: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>, method = 'GET'\nurl = '/html/gndy/dyzz/list_23_1.html', body = None\nheaders = {'Connection': 'close', 'Host': 'www.dytt8.net', 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36'}\nencode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:1275: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:1224: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>, message_body = None\nencode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:1016: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>\ndata = b'GET /html/gndy/dyzz/list_23_1.html HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: www.dytt8.net\\r\\nUser-Agent: Mozil... Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1944.0 Safari/537.36\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:956: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPSConnection object at 0x10d1976a0>\n\n    def connect(self):\n        \"Connect to a host on a given (SSL) port.\"\n    \n        super().connect()\n    \n        if self._tunnel_host:\n            server_hostname = self._tunnel_host\n        else:\n            server_hostname = self.host\n    \n        self.sock = self._context.wrap_socket(self.sock,\n>                                             server_hostname=server_hostname)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py:1392: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLContext object at 0x10d1a1cf0>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = 'www.dytt8.net', session = None\n\n    def wrap_socket(self, sock, server_side=False,\n                    do_handshake_on_connect=True,\n                    suppress_ragged_eofs=True,\n                    server_hostname=None, session=None):\n        # SSLSocket class handles server_hostname encoding before it calls\n        # ctx._wrap_socket()\n        return self.sslsocket_class._create(\n            sock=sock,\n            server_side=server_side,\n            do_handshake_on_connect=do_handshake_on_connect,\n            suppress_ragged_eofs=suppress_ragged_eofs,\n            server_hostname=server_hostname,\n            context=self,\n>           session=session\n        )\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/ssl.py:412: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'ssl.SSLSocket'>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nserver_side = False, do_handshake_on_connect = True, suppress_ragged_eofs = True\nserver_hostname = 'www.dytt8.net'\ncontext = <ssl.SSLContext object at 0x10d1a1cf0>, session = None\n\n    @classmethod\n    def _create(cls, sock, server_side=False, do_handshake_on_connect=True,\n                suppress_ragged_eofs=True, server_hostname=None,\n                context=None, session=None):\n        if sock.getsockopt(SOL_SOCKET, SO_TYPE) != SOCK_STREAM:\n            raise NotImplementedError(\"only stream sockets are supported\")\n        if server_side:\n            if server_hostname:\n                raise ValueError(\"server_hostname can only be specified \"\n                                 \"in client mode\")\n            if session is not None:\n                raise ValueError(\"session can only be specified in \"\n                                 \"client mode\")\n        if context.check_hostname and not server_hostname:\n            raise ValueError(\"check_hostname requires server_hostname\")\n    \n        kwargs = dict(\n            family=sock.family, type=sock.type, proto=sock.proto,\n            fileno=sock.fileno()\n        )\n        self = cls.__new__(cls, **kwargs)\n        super(SSLSocket, self).__init__(**kwargs)\n        self.settimeout(sock.gettimeout())\n        sock.detach()\n    \n        self._context = context\n        self._session = session\n        self._closed = False\n        self._sslobj = None\n        self.server_side = server_side\n        self.server_hostname = context._encode_hostname(server_hostname)\n        self.do_handshake_on_connect = do_handshake_on_connect\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n    \n        # See if we are connected\n        try:\n            self.getpeername()\n        except OSError as e:\n            if e.errno != errno.ENOTCONN:\n                raise\n            connected = False\n        else:\n            connected = True\n    \n        self._connected = connected\n        if connected:\n            # create the SSL object\n            try:\n                self._sslobj = self._context._wrap_socket(\n                    self, server_side, self.server_hostname,\n                    owner=self, session=self._session,\n                )\n                if do_handshake_on_connect:\n                    timeout = self.gettimeout()\n                    if timeout == 0.0:\n                        # non-blocking\n                        raise ValueError(\"do_handshake_on_connect should not be specified for non-blocking sockets\")\n>                   self.do_handshake()\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/ssl.py:853: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>\nblock = False\n\n    def do_handshake(self, block=False):\n        \"\"\"Perform a TLS/SSL handshake.\"\"\"\n        self._check_connected()\n        timeout = self.gettimeout()\n        try:\n            if timeout == 0.0 and block:\n                self.settimeout(None)\n>           self._sslobj.do_handshake()\nE           ssl.SSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate in certificate chain (_ssl.c:1056)\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/ssl.py:1117: SSLCertVerificationError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <spider.testcases.test_02_spider.TestMovieSpider object at 0x10d197710>\n\n    @pytest.mark.usefixtures(\"movie_csv_header_write\")\n    def test_movie_new_round(self):\n        for i in range(1, 2):\n            url = 'https://www.dytt8.net/html/gndy/dyzz/list_23_{}.html'.format(i)\n>           one_level_serch(url)\n\ntest_02_spider.py:12: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nmovie_test/new_movie_serch.py:6: in one_level_serch\n    html = spider.get_html(url, 'GBK')\n../../common/spider.py:15: in get_html\n    res = request.urlopen(req)\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:222: in urlopen\n    return opener.open(url, data, timeout)\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:525: in open\n    response = self._open(req, data)\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:543: in _open\n    '_open', req)\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:503: in _call_chain\n    result = func(*args)\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:1360: in https_open\n    context=self._context, check_hostname=self._check_hostname)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPSHandler object at 0x10d197a90>\nhttp_class = <class 'http.client.HTTPSConnection'>\nreq = <urllib.request.Request object at 0x10d197898>\nhttp_conn_args = {'check_hostname': None, 'context': None}\nhost = '127.0.0.1:8890', h = <http.client.HTTPSConnection object at 0x10d1976a0>\ntunnel_headers = {}, proxy_auth_hdr = 'Proxy-Authorization'\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update({k: v for k, v in req.headers.items()\n                        if k not in headers})\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = {name.title(): val for name, val in headers.items()}\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: self signed certificate in certificate chain (_ssl.c:1056)>\n\n/usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/request.py:1319: URLError"}, "attachments": [{"name": "stdout", "source": "c35de7c8-d237-4c3d-b560-f8e057d629b8-attachment.txt", "type": "text/plain"}], "start": 1652326543635, "stop": 1652326544062, "uuid": "44cd4fc5-fb8e-42c2-94c2-04fa47eab9df", "historyId": "a732a61b480cacad2520b93c53d6114d", "testCaseId": "0e4ff77f89d1771fbfc32da175d000e4", "fullName": "spider.testcases.test_02_spider.TestMovieSpider#test_movie_new_round", "labels": [{"name": "parentSuite", "value": "spider.testcases"}, {"name": "suite", "value": "test_02_spider"}, {"name": "subSuite", "value": "TestMovieSpider"}, {"name": "host", "value": "tongchunyan.local"}, {"name": "thread", "value": "87123-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "spider.testcases.test_02_spider"}]}